<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Talk is cheap. Show me the code</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lizhaobomb.github.io/"/>
  <updated>2020-03-05T15:49:48.814Z</updated>
  <id>https://lizhaobomb.github.io/</id>
  
  <author>
    <name>木子召</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS性能优化09-安装包瘦身</title>
    <link href="https://lizhaobomb.github.io/2020/03/05/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9609-%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/"/>
    <id>https://lizhaobomb.github.io/2020/03/05/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9609-%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/</id>
    <published>2020-03-04T16:10:00.000Z</published>
    <updated>2020-03-05T15:49:48.814Z</updated>
    
    <content type="html"><![CDATA[<p>我们开发完一个项目将来肯定是要进行编译，然后打包上传到APPStore提供给用户下载，那我们最终打包是什么格式呢？其实是一个IPA包，那首先我们来看看安装包的组成</p><h3 id="安装包（ipa）主要由可执行文件、资源组成"><a href="#安装包（ipa）主要由可执行文件、资源组成" class="headerlink" title="安装包（ipa）主要由可执行文件、资源组成"></a>安装包（<code>ipa</code>）主要由可执行文件、资源组成</h3><ul><li><p>资源（图片、音频、视频等）</p><ul><li><p>采取无损压缩:网上有很多，我常用的像 <a href="https://tinypng.com" target="_blank" rel="noopener">TinyPng</a>、<a href="https://squoosh.app/" target="_blank" rel="noopener">Squoosh</a>、<a href="https://www.tuhaokuai.com" target="_blank" rel="noopener">图好快</a> 等等</p></li><li><p>去除没用到的资源：大家可以试试GitHub上有个开源项目可以检测项目里没用的资源文件 <a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">GitHub传送门</a></p></li></ul></li><li><p>可执行文件瘦身</p><ul><li><p>编译器优化 现在的新版<code>Xcode</code>已经自动给优化了，如果你的项目比较旧的话，可以去<code>XCode</code>设置这些选项，不确定的话最好都去搜下然后设置下 <code>Strip Linked Product</code>、<code>Make Strings Read-Only</code>、<code>Symbols Hidden by Default</code>设置为<code>YES</code><br><a href="https://ae01.alicdn.com/kf/Uc24885f572f84ceb87bc5e3f5812159bQ.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://ae01.alicdn.com/kf/Uc24885f572f84ceb87bc5e3f5812159bQ.jpg" class="lazyload"></a></p></li><li><p>去掉异常支持，<code>Enable C++ Exceptions</code>、<code>Enable Objective-C Exceptions</code>设置为<code>NO</code>， <code>Other C Flags</code>添加<code>-fno-exceptions</code></p></li><li><p>利用<a href="https://www.jetbrains.com/objc/" target="_blank" rel="noopener">AppCode</a>（这个软件是收费的，可以试用30天，当然有钱的大家可以支持下正版，没钱的话想办法也可以搞到）检测未使用的代码：<code>菜单栏 -&gt; Code -&gt; Inspect Code</code></p></li><li><p>编写<code>LLVM</code>插件检测出重复代码、未被调用的代码（这个比较高级，也比较复杂，涉及到的知识有点多，后面会用专门一篇文章来记录）</p></li><li><p>还有个东西叫<code>LinkMap</code>(可以查看可执行文件的具体组成),我们可以用<code>Xcode</code>来生成<code>LinkMap</code>文件<br><a href="https://ae01.alicdn.com/kf/U84b8d327052040e5a89a485d63a7dc144.jpg" data-fancybox="group" data-caption="LinkMap" class="fancybox"><img alt="LinkMap" title="LinkMap" data-src="https://ae01.alicdn.com/kf/U84b8d327052040e5a89a485d63a7dc144.jpg" class="lazyload"></a><br>不过系统生成的这个txt文件可能看着比较难分析，那么我们可以借助三方工具来分析<code>LinkMap</code>文件，<code>GItHub</code>上有开源<code>Mac OS</code>项目，大家下载完编译完就可以用了</p></li></ul></li><li><p><a href="https://github.com/huanxsd/LinkMap" target="_blank" rel="noopener">解析LinkMap文件工具传送门</a></p></li></ul><p>解析前</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># Sections:</span><br><span class="line"># AddressSize    SegmentSection</span><br><span class="line">0x100000F300x00000553__TEXT__text</span><br><span class="line">0x1000014840x0000003C__TEXT__stubs</span><br><span class="line">0x1000014C00x00000074__TEXT__stub_helper</span><br><span class="line">0x1000015340x00000D26__TEXT__objc_methname</span><br><span class="line">0x10000225A0x00000070__TEXT__objc_classname</span><br><span class="line">0x1000022CA0x00000ADA__TEXT__objc_methtype</span><br><span class="line">0x100002DA40x00000090__TEXT__cstring</span><br><span class="line">0x100002E340x0000017E__TEXT__entitlements</span><br><span class="line">0x100002FB40x00000048__TEXT__unwind_info</span><br><span class="line">0x1000030000x00000018__DATA_CONST__got</span><br><span class="line">0x1000030180x00000020__DATA_CONST__cfstring</span><br><span class="line">0x1000030380x00000018__DATA_CONST__objc_classlist</span><br><span class="line">0x1000030500x00000020__DATA_CONST__objc_protolist</span><br><span class="line">0x1000030700x00000008__DATA_CONST__objc_imageinfo</span><br><span class="line">0x1000040000x00000050__DATA__la_symbol_ptr</span><br><span class="line">0x1000040500x00001308__DATA__objc_const</span><br><span class="line">0x1000053580x00000018__DATA__objc_selrefs</span><br><span class="line">0x1000053700x00000010__DATA__objc_classrefs</span><br><span class="line">0x1000053800x00000008__DATA__objc_superrefs</span><br><span class="line">0x1000053880x00000008__DATA__objc_ivar</span><br><span class="line">0x1000053900x000000F0__DATA__objc_data</span><br><span class="line">0x1000054800x00000188__DATA__data</span><br><span class="line"># Symbols:</span><br><span class="line"># AddressSize    File  Name</span><br><span class="line">0x100000F300x00000039[  2] -[ViewController viewDidLoad]</span><br><span class="line">0x100000F700x00000080[  3] -[AppDelegate application:didFinishLaunchingWithOptions:]</span><br><span class="line">0x100000FF00x00000120[  3] -[AppDelegate application:configurationForConnectingSceneSession:options:]</span><br><span class="line">0x1000011100x0000006C[  3] -[AppDelegate application:didDiscardSceneSessions:]</span><br><span class="line">0x1000011800x00000090[  4] _main</span><br><span class="line">0x1000012100x000000A0[  5] -[SceneDelegate scene:willConnectToSession:options:]</span><br><span class="line">0x1000012B00x00000040[  5] -[SceneDelegate sceneDidDisconnect:]</span><br><span class="line">0x1000012F00x00000040[  5] -[SceneDelegate sceneDidBecomeActive:]</span><br><span class="line">0x1000013300x00000040[  5] -[SceneDelegate sceneWillResignActive:]</span><br><span class="line">0x1000013700x00000040[  5] -[SceneDelegate sceneWillEnterForeground:]</span><br><span class="line">0x1000013B00x00000040[  5] -[SceneDelegate sceneDidEnterBackground:]</span><br><span class="line">0x1000013F00x00000020[  5] -[SceneDelegate window]</span><br><span class="line">0x1000014100x00000040[  5] -[SceneDelegate setWindow:]</span><br><span class="line">0x1000014500x00000033[  5] -[SceneDelegate .cxx_destruct]</span><br><span class="line">0x1000014840x00000006[  6] _NSStringFromClass</span><br></pre></td></tr></table></figure></div><p>解析后：<br><a href="https://ae01.alicdn.com/kf/Ue44e074f9f6a4df78e2740c56b1536074.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://ae01.alicdn.com/kf/Ue44e074f9f6a4df78e2740c56b1536074.jpg" class="lazyload"></a></p><p>-</p><h1 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h1><p><a href="https://docs.qq.com/sheet/DQkhZTVdhbVB2dEVO?c=A2A0A0" target="_blank" rel="noopener">点击查看 2020—课程列表 全网IT各种资源有需求的可以微我，或者你喜欢的课程都可以给我发链接剩下的我来搞定</a></p><p>喜欢的朋友可以扫描关注我的公众号(多多点赞，多多打赏，您的支持是我写作的最大动力）<code>关注有福利可以使用免费梯子自由上网</code></p><p><a href="https://ae01.alicdn.com/kf/Udde8350c2b484ac6b4d7f9c3ea1c52822.jpg" data-fancybox="group" data-caption="iOS_DevTips" class="fancybox"><img alt="iOS_DevTips" title="iOS_DevTips" data-src="https://ae01.alicdn.com/kf/Udde8350c2b484ac6b4d7f9c3ea1c52822.jpg" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      我们开发完一个项目将来肯定是要进行编译，然后打包上传到APPStore提供给用户下载，那我们最终打包是什么格式呢？其实是一个IPA包，那首先我们来看看安装包的组成

安装包（ipa）主要由可执行文件、资源组成
 * 资源（图片、音频、视频等）
   
    * 采取无损压缩:网上有很多，我常用的像 TinyPng、Squoosh、图好快 等等
      
      
    * 去除没用到的资源：大家可以试试GitHub上有个开源项目可以检测项目里没用的资源文件 GitHub传送门
      
      
   
   
 * 可执行文件瘦身
   
    * 编译器优化 现在的新
    
    </summary>
    
    
      <category term="iOS" scheme="https://lizhaobomb.github.io/categories/iOS/"/>
    
      <category term="性能优化" scheme="https://lizhaobomb.github.io/categories/iOS/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="iOS" scheme="https://lizhaobomb.github.io/tags/iOS/"/>
    
      <category term="性能" scheme="https://lizhaobomb.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="瘦身" scheme="https://lizhaobomb.github.io/tags/%E7%98%A6%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>iOS性能优化08-启动优化02-分析</title>
    <link href="https://lizhaobomb.github.io/2020/03/04/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9608-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%9602-%E5%88%86%E6%9E%90/"/>
    <id>https://lizhaobomb.github.io/2020/03/04/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9608-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%9602-%E5%88%86%E6%9E%90/</id>
    <published>2020-03-03T16:10:00.000Z</published>
    <updated>2020-03-04T15:28:26.522Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们已经把APP的启动大致概括为<code>dyld</code>，<code>runtime</code>, <code>main</code>这三阶段，那接下来我们具体看看这三个阶段都在做些什么事情</p><h3 id="第一阶段dyld（dynamic-link-editor），"><a href="#第一阶段dyld（dynamic-link-editor），" class="headerlink" title="第一阶段dyld（dynamic link editor），"></a>第一阶段<code>dyld（dynamic link editor）</code>，</h3><p>Apple的动态链接器，可以用来装载<code>Mach-O</code>文件（可执行文件、动态库等）</p><ul><li>启动APP时，<code>dyld</code>所做的事情有<ul><li>装载APP的可执行文件，同时会递归加载所有依赖的动态库</li><li>当<code>dyld</code>把<code>可执行文件</code>、<code>动态库</code>都装载完毕后，会通知<code>Runtime</code>进行下一步的处理</li></ul></li></ul><h3 id="第二阶段-runtime"><a href="#第二阶段-runtime" class="headerlink" title="第二阶段 runtime"></a>第二阶段 runtime</h3><ul><li>启动APP时，<code>runtime</code>所做的事情有<ul><li>调用<code>map_images</code>进行可执行文件内容的解析和处理</li><li>在<code>load_images</code>中调用<code>call_load_methods</code>，调用所有<code>Class</code>和<code>Category</code>的<code>+load</code>方法</li><li>进行各种objc结构的初始化（注册Objc类，初始化类对象等等）</li><li>调用C++静态初始化器和<code>__attribute__((constructor))</code>修饰的函数</li></ul></li></ul><p>到此为止，可执行文件和动态库中所有的符号<code>（Class，Protocol，Selector，IMP，...)</code>都已经按格式成功加载到内存中，被<code>runtime</code>所管理</p><h3 id="第三阶段-main"><a href="#第三阶段-main" class="headerlink" title="第三阶段 main"></a>第三阶段 main</h3><ul><li>总结一下<ul><li>APP的启动由<code>dyld</code>主导，将可执行文件加载到内存，顺便加载所有依赖的动态库</li><li>并由<code>runtime</code>负责加载成<code>objc</code>定义的结构</li><li>所有初始化工作结束后，<code>dyld</code>就会调用<code>main</code>函数</li><li>接下来就是<code>UIApplicationMain</code>函数，<code>APPDelegate</code>的<code>application:didFinishLaunchingWithOptions:</code>方法</li></ul></li></ul><p>接下来我们来看看如何进行优化</p><h2 id="APP的启动优化"><a href="#APP的启动优化" class="headerlink" title="APP的启动优化"></a>APP的启动优化</h2><p>按照不同的阶段来展开</p><ul><li><p>dyld</p><ul><li>减少动态库、合并一些动态库（定期清理不必要的动态库）</li><li>减少<code>Objc</code>类、分类的数量、减少<code>Selector</code>数量（定期清理不必要的类、分类）</li><li>减少<code>C++虚函数</code>的数量</li><li><code>Swift</code>尽量使用<code>Struct</code></li></ul></li><li><p>runtime</p><ul><li>用<code>+initialize</code>方法和<code>dispatch_once</code>取代所有的<code>__attribute__((constructor))</code>、<code>C++静态构造器</code>、Objc的<code>+load</code></li></ul></li><li><p>main</p><ul><li>在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在<code>finishLaunching</code>方法中</li><li>按需加载</li></ul></li></ul><h1 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h1><p><a href="https://docs.qq.com/sheet/DQkhZTVdhbVB2dEVO?c=A2A0A0" target="_blank" rel="noopener">点击查看 2020—课程列表 全网IT各种资源有需求的可以微我，或者你喜欢的课程都可以给我发链接剩下的我来搞定</a></p><p>喜欢的朋友可以扫描关注我的公众号(多多点赞，多多打赏，您的支持是我写作的最大动力）<code>关注有福利可以使用免费梯子自由上网</code></p><p><a href="https://ae01.alicdn.com/kf/Udde8350c2b484ac6b4d7f9c3ea1c52822.jpg" data-fancybox="group" data-caption="iOS_DevTips" class="fancybox"><img alt="iOS_DevTips" title="iOS_DevTips" data-src="https://ae01.alicdn.com/kf/Udde8350c2b484ac6b4d7f9c3ea1c52822.jpg" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      上一节我们已经把APP的启动大致概括为dyld，runtime, main这三阶段，那接下来我们具体看看这三个阶段都在做些什么事情

第一阶段dyld（dynamic link editor），
Apple的动态链接器，可以用来装载Mach-O文件（可执行文件、动态库等）

 * 启动APP时，dyld所做的事情有 * 装载APP的可执行文件，同时会递归加载所有依赖的动态库
    * 当dyld把可执行文件、动态库都装载完毕后，会通知Runtime进行下一步的处理
   
   

第二阶段 runtime
 * 启动APP时，runtime所做的事情有 * 调用map_images进行可执
    
    </summary>
    
    
      <category term="iOS" scheme="https://lizhaobomb.github.io/categories/iOS/"/>
    
      <category term="性能优化" scheme="https://lizhaobomb.github.io/categories/iOS/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="iOS" scheme="https://lizhaobomb.github.io/tags/iOS/"/>
    
      <category term="性能" scheme="https://lizhaobomb.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="耗电" scheme="https://lizhaobomb.github.io/tags/%E8%80%97%E7%94%B5/"/>
    
  </entry>
  
  <entry>
    <title>iOS性能优化07-启动优化01-冷启动简介</title>
    <link href="https://lizhaobomb.github.io/2020/03/03/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9607-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%9601-%E5%86%B7%E5%90%AF%E5%8A%A8%E7%AE%80%E4%BB%8B/"/>
    <id>https://lizhaobomb.github.io/2020/03/03/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9607-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%9601-%E5%86%B7%E5%90%AF%E5%8A%A8%E7%AE%80%E4%BB%8B/</id>
    <published>2020-03-02T16:10:00.000Z</published>
    <updated>2020-03-03T15:24:47.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="APP的启动可以分为2种："><a href="#APP的启动可以分为2种：" class="headerlink" title="APP的启动可以分为2种："></a>APP的启动可以分为2种：</h2><ul><li><p>冷启动（Cold Launch）：从零开始启动APP</p></li><li><p>热启动 （Warm Launch）：APP已经在内存中，在后台存活着，再次点击图标启动APP</p></li></ul><h2 id="APP启动时间的优化"><a href="#APP启动时间的优化" class="headerlink" title="APP启动时间的优化"></a>APP启动时间的优化</h2><p>那我们通常所说的启动时间优化都是再说的冷启动的时间优化，其实Xcode是提供给我们一种分析启动时间的方式，我们接下来试一试</p><ul><li><p>通过添加环境变量可以打印出APP的启动时间分析（<code>Edit Scheme -&gt; Run -&gt; Arguments</code>)</p><ul><li><p><code>DYLD_PRINT_STATISTICS</code>设置为<code>1</code></p><p><a href="https://ae01.alicdn.com/kf/U6741e3dbe662435580206747f8385eaeA.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://ae01.alicdn.com/kf/U6741e3dbe662435580206747f8385eaeA.jpg" class="lazyload"></a></p><p>我们可以看到控制台打印出了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Total pre-main time: 238.11 milliseconds (100.0%)</span><br><span class="line">       dylib loading time: 173.78 milliseconds (72.9%)</span><br><span class="line">      rebase&#x2F;binding time: 126687488.9 seconds (15889931.7%)</span><br><span class="line">          ObjC setup time:  15.16 milliseconds (6.3%)</span><br><span class="line">         initializer time:  62.59 milliseconds (26.2%)</span><br><span class="line">         slowest intializers :</span><br><span class="line">           libSystem.B.dylib :   6.66 milliseconds (2.7%)</span><br><span class="line"> libBacktraceRecording.dylib :   7.30 milliseconds (3.0%)</span><br><span class="line">  libMainThreadChecker.dylib :  40.12 milliseconds (16.8%)</span><br></pre></td></tr></table></figure></div></li><li><p>如果需要更详细的信息，那就将<code>DYLD_PRINT_STATISTICS_DETAILS</code>设置为<code>1</code></p><p>我们看到这次输出的信息比上次要详细很多</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  total time: 981.15 milliseconds (100.0%)</span><br><span class="line">  total images loaded:  334 (327 from dyld shared cache)</span><br><span class="line">  total segments mapped: 21, into 370 pages</span><br><span class="line">  total images loading time: 664.10 milliseconds (67.6%)</span><br><span class="line">  total load time in ObjC:  20.03 milliseconds (2.0%)</span><br><span class="line">  total debugger pause time: 402.89 milliseconds (41.0%)</span><br><span class="line">  total dtrace DOF registration time:   0.22 milliseconds (0.0%)</span><br><span class="line">  total rebase fixups:  17,951</span><br><span class="line">  total rebase fixups time:   2.27 milliseconds (0.2%)</span><br><span class="line">  total binding fixups: 460,826</span><br><span class="line">  total binding fixups time: 229.13 milliseconds (23.3%)</span><br><span class="line">  total weak binding fixups time:   0.03 milliseconds (0.0%)</span><br><span class="line">  total redo shared cached bindings time: 254.48 milliseconds (25.9%)</span><br><span class="line">  total bindings lazily fixed up: 0 of 0</span><br><span class="line">  total time in initializers and ObjC +load:  65.34 milliseconds (6.6%)</span><br><span class="line">                         libSystem.B.dylib :   9.14 milliseconds (0.9%)</span><br><span class="line">               libBacktraceRecording.dylib :   7.73 milliseconds (0.7%)</span><br><span class="line">                           libobjc.A.dylib :   1.55 milliseconds (0.1%)</span><br><span class="line">                            CoreFoundation :   2.24 milliseconds (0.2%)</span><br><span class="line">                libMainThreadChecker.dylib :  38.86 milliseconds (3.9%)</span><br><span class="line">                    libLLVMContainer.dylib :   2.13 milliseconds (0.2%)</span><br><span class="line">total symbol trie searches:    1116978</span><br><span class="line">total symbol table binary searches:    0</span><br><span class="line">total images defining weak symbols:  37</span><br><span class="line">total images using weak symbols:  92</span><br></pre></td></tr></table></figure></div></li></ul></li></ul><p>这些数据可能对大家来说不太直观，这其实只是提供给大家一个参考，一般我个人认为total time在<br>400~500ms之间就相对来说是比较正常的，如果时间太长就可能要进行相应的优化了，接下来我们来看看冷启动的大概分哪几个阶段</p><h2 id="APP冷启动阶段可以概括为3大阶段"><a href="#APP冷启动阶段可以概括为3大阶段" class="headerlink" title="APP冷启动阶段可以概括为3大阶段"></a>APP冷启动阶段可以概括为3大阶段</h2><ul><li>dyld</li><li>runtime</li><li>main</li></ul><p><a href="https://ae01.alicdn.com/kf/Ud91e5d552eb842a4aa60364d9be1a38eE.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://ae01.alicdn.com/kf/Ud91e5d552eb842a4aa60364d9be1a38eE.jpg" class="lazyload"></a></p><h1 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h1><p><a href="https://docs.qq.com/sheet/DQkhZTVdhbVB2dEVO?c=A2A0A0" target="_blank" rel="noopener">点击查看 2020—课程列表 全网IT各种资源有需求的可以微我，或者你喜欢的课程都可以给我发链接剩下的我来搞定</a></p><p>喜欢的朋友可以扫描关注我的公众号(多多点赞，多多打赏，您的支持是我写作的最大动力）<code>关注有福利可以使用免费梯子自由上网</code></p><p><a href="https://ae01.alicdn.com/kf/Udde8350c2b484ac6b4d7f9c3ea1c52822.jpg" data-fancybox="group" data-caption="iOS_DevTips" class="fancybox"><img alt="iOS_DevTips" title="iOS_DevTips" data-src="https://ae01.alicdn.com/kf/Udde8350c2b484ac6b4d7f9c3ea1c52822.jpg" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      APP的启动可以分为2种：
 * 冷启动（Cold Launch）：从零开始启动APP
   
   
 * 热启动 （Warm Launch）：APP已经在内存中，在后台存活着，再次点击图标启动APP
   
   

APP启动时间的优化
那我们通常所说的启动时间优化都是再说的冷启动的时间优化，其实Xcode是提供给我们一种分析启动时间的方式，我们接下来试一试

 * 通过添加环境变量可以打印出APP的启动时间分析（Edit Scheme -&gt; Run -&gt; Arguments)
   
    * DYLD_PRINT_STATISTICS设置为1
      
      
     
    
    </summary>
    
    
      <category term="iOS" scheme="https://lizhaobomb.github.io/categories/iOS/"/>
    
      <category term="性能优化" scheme="https://lizhaobomb.github.io/categories/iOS/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="iOS" scheme="https://lizhaobomb.github.io/tags/iOS/"/>
    
      <category term="性能" scheme="https://lizhaobomb.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="耗电" scheme="https://lizhaobomb.github.io/tags/%E8%80%97%E7%94%B5/"/>
    
  </entry>
  
  <entry>
    <title>iOS性能优化06 - 耗电优化</title>
    <link href="https://lizhaobomb.github.io/2020/03/02/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%20-%20%E8%80%97%E7%94%B5%E4%BC%98%E5%8C%96/"/>
    <id>https://lizhaobomb.github.io/2020/03/02/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%20-%20%E8%80%97%E7%94%B5%E4%BC%98%E5%8C%96/</id>
    <published>2020-03-01T16:10:00.000Z</published>
    <updated>2020-03-02T16:14:35.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="耗电的主要来源"><a href="#耗电的主要来源" class="headerlink" title="耗电的主要来源"></a>耗电的主要来源</h2><p><a href="https://ae01.alicdn.com/kf/Uc4ae257eb7b5461d8f9977c40207fc12K.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://ae01.alicdn.com/kf/Uc4ae257eb7b5461d8f9977c40207fc12K.jpg" class="lazyload"></a></p><ul><li><p>CPU处理，Processing</p></li><li><p>网络， Networking</p></li><li><p>定位，Location</p></li><li><p>图像，Graphics</p></li></ul><h2 id="耗电优化的几条建议"><a href="#耗电优化的几条建议" class="headerlink" title="耗电优化的几条建议"></a>耗电优化的几条建议</h2><ul><li><p>尽可能降低CPU、GPU功耗</p></li><li><p>少用定时器</p></li><li><p>优化I/O操作</p><ul><li>尽量不要频繁写入小数据，最好批量一次性写入</li><li>读写大量重要数据时，考虑使用<code>dispatch_io</code>, 其提供了基于GCD的异步操作文件I/O的API。用<code>dispatch_io</code>系统会优化磁盘访问</li><li>数据量比较大的，建议使用数据库（比如<code>SQLite</code>、<code>CoreData</code>）(可能好多同学都直接写一个<code>plist</code>文件或者用<code>NSKeyArchive</code>归档到一个文件里，当数据量大的时候不建议这样写，因为数据库毕竟对读数据或者写数据是有优化过的）</li></ul></li><li><p>网络优化</p><ul><li>减少、压缩网络数据（比如我们之前给服务器交互的时候可能用的是XML，XML的一个缺点就是体积比较大因为格式比较臃肿，现在我们改为JSON体积就会减少很多，当然现在有很多公司在用<a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">protocol buffers</a>更小更快更简单，感兴趣的同学可以点击链接研究）</li><li>如果多次请求的结果是相同的，尽量使用缓存</li><li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li><li>网络不可用时， 不要尝试执行网络请求</li><li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间</li><li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块的下载。如果下载广告，一次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次性下载多封，不要一封一封地下载</li></ul></li><li><p>定位优化</p><ul><li>如果只是需要快速确定用户的位置，最好用<code>CLLocationManager</code>的<code>requestLocation</code>方法。定位完成后，会自动让定位硬件断电</li><li>如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务</li><li>尽量降低定位精度，比如尽量不要使用精度最高的<code>kCLLocationAccuracyBest</code></li><li>需要后台定位时，尽量设置<code>pausesLocationUpdatesAutomatically</code>为<code>YES</code>，如果用户不太可能移动的时候系统会自动暂停位置更新</li><li>尽量不要使用<code>startMonitoringSignificantLocationChanges</code>，优先考虑<code>startMonitoringForRegion:</code></li></ul></li><li><p>硬件检测优化</p><ul><li>用户移动、摇晃、倾斜设备时，会产生动作（<code>motion</code>）事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件</li></ul></li></ul><h1 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h1><p><a href="https://docs.qq.com/sheet/DQkhZTVdhbVB2dEVO?c=A2A0A0" target="_blank" rel="noopener">点击查看 2020—课程列表 全网IT各种资源有需求的可以微我，或者你喜欢的课程都可以给我发链接剩下的我来搞定</a></p><p>喜欢的朋友可以扫描关注我的公众号(多多点赞，多多打赏，您的支持是我写作的最大动力）</p><p><a href="https://ae01.alicdn.com/kf/Udde8350c2b484ac6b4d7f9c3ea1c52822.jpg" data-fancybox="group" data-caption="iOS_DevTips" class="fancybox"><img alt="iOS_DevTips" title="iOS_DevTips" data-src="https://ae01.alicdn.com/kf/Udde8350c2b484ac6b4d7f9c3ea1c52822.jpg" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      耗电的主要来源


 * CPU处理，Processing
   
   
 * 网络， Networking
   
   
 * 定位，Location
   
   
 * 图像，Graphics
   
   

耗电优化的几条建议
 * 尽可能降低CPU、GPU功耗
   
   
 * 少用定时器
   
   
 * 优化I/O操作
   
    * 尽量不要频繁写入小数据，最好批量一次性写入
    * 读写大量重要数据时，考虑使用dispatch_io, 其提供了基于GCD的异步操作文件I/O的API。用dispatch_io系统会优化磁盘访问
    * 数据量比较大的，
    
    </summary>
    
    
      <category term="iOS" scheme="https://lizhaobomb.github.io/categories/iOS/"/>
    
      <category term="性能优化" scheme="https://lizhaobomb.github.io/categories/iOS/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="iOS" scheme="https://lizhaobomb.github.io/tags/iOS/"/>
    
      <category term="性能" scheme="https://lizhaobomb.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="耗电" scheme="https://lizhaobomb.github.io/tags/%E8%80%97%E7%94%B5/"/>
    
  </entry>
  
  <entry>
    <title>iOS性能优化05-卡顿优化03-卡顿监测</title>
    <link href="https://lizhaobomb.github.io/2020/03/01/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605-%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%9603-%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%B5%8B/"/>
    <id>https://lizhaobomb.github.io/2020/03/01/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605-%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%9603-%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%B5%8B/</id>
    <published>2020-02-29T16:20:47.000Z</published>
    <updated>2020-03-04T15:34:11.060Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>平时所说的”卡顿“主要是因为在主线程执行了比较耗时的操作阻塞了主线程造成的</p></li><li><p>可以添加Observer到主线程Runloop中，通过监听Runloop状态切换的耗时，以达到监控卡顿的目的</p></li></ul><p>下面我们来具体看看如何用代码实现</p><p>首先我们先看看Runloop的运行逻辑<br><a href="https://upload-images.jianshu.io/upload_images/112869-3d96c6551f26b3b1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="Runloop运行逻辑" class="fancybox"><img alt="Runloop运行逻辑" title="Runloop运行逻辑" data-src="https://upload-images.jianshu.io/upload_images/112869-3d96c6551f26b3b1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></a></p><p>我们知道我们主线程大部分的操作（比如点击事件的处理、view的绘制计算等等）都是在<code>source0</code>和<code>source1</code>之间，所以我们只要监控下<code>结束休眠处理source1一直到绕回来处理source0这种所消耗的时间</code>，如果发现这次Runloop所消耗的时间比较长，有可能就证明这些操作就比较耗时了，所以我们卡顿监测就是这样子一个效果，最好是能把导致耗时的代码是哪个方法监测出来，我们自己来写这个代码也是可以的，但是比较复杂，我从网上找了个写好的大家可以参考下源码</p><p><a href="https://github.com/UIControl/LXDAppFluecyMonitor" target="_blank" rel="noopener">源码链接</a></p><p>我们跑下demo看下<br>我们滑动列表会发现卡顿并且在控制台有输出监测到导致卡顿的方法调用栈</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">2020-03-01 22:42:24.696074+0800 LXDAppFluecyMonitor[8018:288367] Backtrace of Thread 771:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">libsystem_kernel.dylib         0x7fff523b8bba __semwait_signal + 10</span><br><span class="line">libsystem_c.dylib              0x7fff52348352 sleep + 41</span><br><span class="line">LXDAppFluecyMonitor            0x10bab858f -[ViewController tableView:cellForRowAtIndexPath:] + 351</span><br><span class="line">UIKitCore                      0x7fff48297462 -[UITableView _createPreparedCellForGlobalRow:withIndexPath:willDisplay:] + 781</span><br><span class="line">UIKitCore                      0x7fff4826043b -[UITableView _updateVisibleCellsNow:] + 3081</span><br><span class="line">UIKitCore                      0x7fff4828055f -[UITableView layoutSubviews] + 194</span><br><span class="line">UIKitCore                      0x7fff485784bd -[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 2478</span><br><span class="line">QuartzCore                     0x7fff2b131db1 -[CALayer layoutSublayers] + 255</span><br><span class="line">QuartzCore                     0x7fff2b137fa3 _ZN2CA5Layer16layout_if_neededEPNS_11TransactionE + 517</span><br><span class="line">QuartzCore                     0x7fff2b1438da _ZN2CA5Layer28layout_and_display_if_neededEPNS_11TransactionE + 80</span><br><span class="line">QuartzCore                     0x7fff2b08a848 _ZN2CA7Context18commit_transactionEPNS_11TransactionEd + 324</span><br><span class="line">QuartzCore                     0x7fff2b0bfb51 _ZN2CA11Transaction6commitEv + 643</span><br><span class="line">QuartzCore                     0x7fff2afeb37f _ZN2CA7Display11DisplayLink14dispatch_itemsEyyy + 921</span><br><span class="line">QuartzCore                     0x7fff2b0c3e03 _ZL22display_timer_callbackP12__CFMachPortPvlS1_ + 299</span><br><span class="line">CoreFoundation                 0x7fff23b9503d __CFMachPortPerform + 157</span><br><span class="line">CoreFoundation                 0x7fff23bd4bc9 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ + 41</span><br><span class="line">CoreFoundation                 0x7fff23bd4228 __CFRunLoopDoSource1 + 472</span><br><span class="line">CoreFoundation                 0x7fff23bced64 __CFRunLoopRun + 2516</span><br><span class="line">CoreFoundation                 0x7fff23bce066 CFRunLoopRunSpecific + 438</span><br><span class="line">GraphicsServices               0x7fff384c0bb0 GSEventRunModal + 65</span><br><span class="line">UIKitCore                      0x7fff48092d4d UIApplicationMain + 1621</span><br><span class="line">LXDAppFluecyMonitor            0x10bab9a40 main + 112</span><br><span class="line">libdyld.dylib                  0x7fff5227ec25 start + 1</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure></div><p>我们看到代码中在:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (UITableViewCell *)tableView: (UITableView *)tableView cellForRowAtIndexPath: (NSIndexPath *)indexPath &#123;</span><br><span class="line">    UITableViewCell * cell &#x3D; [tableView dequeueReusableCellWithIdentifier: @&quot;cell&quot;];</span><br><span class="line">    cell.textLabel.text &#x3D; [NSString stringWithFormat: @&quot;%lu&quot;, indexPath.row];</span><br><span class="line">    if (indexPath.row &gt; 0 &amp;&amp; indexPath.row % 30 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">&#x2F;&#x2F;        usleep(2000000);</span><br><span class="line">        sleep(2.0);</span><br><span class="line">    &#125;</span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>有人主动休眠了2s，那肯定会卡顿2s的导致的耗时</p><p>我们在<code>didSelectRowAtIndexPath</code>方法里再测试下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)tableView: (UITableView *)tableView didSelectRowAtIndexPath: (NSIndexPath *)indexPath &#123;    </span><br><span class="line">    sleep(2.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们看到控制台也有输出卡顿的方法调用栈，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">libsystem_kernel.dylib         0x7fff523b8bba __semwait_signal + 10</span><br><span class="line">libsystem_c.dylib              0x7fff52348352 sleep + 41</span><br><span class="line">LXDAppFluecyMonitor            0x10bab8640 -[ViewController tableView:didSelectRowAtIndexPath:] + 80</span><br><span class="line">UIKitCore                      0x7fff4827a42b -[UITableView _selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:isCellMultiSelect:] + 855</span><br><span class="line">UIKitCore                      0x7fff4827a0bd -[UITableView _selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:] + 97</span><br><span class="line">UIKitCore                      0x7fff4827a8e8 -[UITableView _userSelectRowAtPendingSelectionIndexPath:] + 334</span><br><span class="line">UIKitCore                      0x7fff4809be5b _runAfterCACommitDeferredBlocks + 352</span><br><span class="line">UIKitCore                      0x7fff4808c7b4 _cleanUpAfterCAFlushAndRunDeferredBlocks + 248</span><br><span class="line">UIKitCore                      0x7fff480bc3a9 _afterCACommitHandler + 85</span><br><span class="line">CoreFoundation                 0x7fff23bd3867 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 23</span><br><span class="line">CoreFoundation                 0x7fff23bce2fe __CFRunLoopDoObservers + 430</span><br><span class="line">CoreFoundation                 0x7fff23bce97a __CFRunLoopRun + 1514</span><br><span class="line">CoreFoundation                 0x7fff23bce066 CFRunLoopRunSpecific + 438</span><br><span class="line">GraphicsServices               0x7fff384c0bb0 GSEventRunModal + 65</span><br><span class="line">UIKitCore                      0x7fff48092d4d UIApplicationMain + 1621</span><br><span class="line">LXDAppFluecyMonitor            0x10bab9a40 main + 112</span><br><span class="line">libdyld.dylib                  0x7fff5227ec25 start + 1</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure></div><p>所以这个demo是完全可以监测卡顿的，那我们来简单看下代码的逻辑，方法调用栈的打印就不过多介绍了，因为比较复杂大家有兴趣可以参考源码里的<code>Backtrack</code>文件里的代码自己去研究下，接下来我们就看看作者的逻辑：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先创建observer，监听所有Runloop状态</span><br><span class="line">_observer &#x3D; CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;lxdRunLoopObserverCallback, &amp;context);</span><br><span class="line">&#x2F;&#x2F; 添加observer</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);</span><br><span class="line">&#x2F;&#x2F; 创建循环监听Runloop各种状态下的耗时，如果超过预定的值就认为是卡顿并打印出来</span><br><span class="line">    dispatch_async(lxd_fluecy_monitor_queue(), ^&#123;</span><br><span class="line">        while (SHAREDMONITOR.isMonitoring) &#123;</span><br><span class="line">            long waitTime &#x3D; dispatch_semaphore_wait(self.semphore, dispatch_time(DISPATCH_TIME_NOW, lxd_wait_interval));</span><br><span class="line">            if (waitTime !&#x3D; LXD_SEMPHORE_SUCCESS) &#123;</span><br><span class="line">                if (!SHAREDMONITOR.observer) &#123;</span><br><span class="line">                    SHAREDMONITOR.timeOut &#x3D; 0;</span><br><span class="line">                    [SHAREDMONITOR stopMonitoring];</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (SHAREDMONITOR.currentActivity &#x3D;&#x3D; kCFRunLoopBeforeSources || SHAREDMONITOR.currentActivity &#x3D;&#x3D; kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                    if (++SHAREDMONITOR.timeOut &lt; 5) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    [LXDBacktraceLogger lxd_logMain];</span><br><span class="line">                    [NSThread sleepForTimeInterval: lxd_restore_interval];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            SHAREDMONITOR.timeOut &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>喜欢的朋友可以扫描关注我的公众号(多多点赞，多多打赏，您的支持是我写作的最大动力）</p><p><a href="https://ae01.alicdn.com/kf/Udde8350c2b484ac6b4d7f9c3ea1c52822.jpg" data-fancybox="group" data-caption="iOS_DevTips" class="fancybox"><img alt="iOS_DevTips" title="iOS_DevTips" data-src="https://ae01.alicdn.com/kf/Udde8350c2b484ac6b4d7f9c3ea1c52822.jpg" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      * 平时所说的”卡顿“主要是因为在主线程执行了比较耗时的操作阻塞了主线程造成的
   
   
 * 可以添加Observer到主线程Runloop中，通过监听Runloop状态切换的耗时，以达到监控卡顿的目的
   
   

下面我们来具体看看如何用代码实现

首先我们先看看Runloop的运行逻辑


我们知道我们主线程大部分的操作（比如点击事件的处理、view的绘制计算等等）都是在source0和source1之间，所以我们只要监控下结束休眠处理source1一直到绕回来处理source0这种所消耗的时间，如果发现这次Runloop所消耗的时间比较长，有可能就证明这些操作就比较耗时了，
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://lizhaobomb.github.io/tags/iOS/"/>
    
      <category term="性能优化" scheme="https://lizhaobomb.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS性能优化04-卡顿优化02-GPU</title>
    <link href="https://lizhaobomb.github.io/2020/02/29/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604-%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%9602-GPU/"/>
    <id>https://lizhaobomb.github.io/2020/02/29/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604-%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%9602-GPU/</id>
    <published>2020-02-28T16:20:47.000Z</published>
    <updated>2020-02-29T15:37:25.294Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>尽量减少视图数量和层次</p></li><li><p>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</p></li><li><p>减少透明的视图（alpha&lt;1)，不透明的就设置opaque为YES</p></li><li><p>GPU能处理的最大纹理尺寸是4096*4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸</p></li><li><p>尽量避免出现离屏渲染</p></li></ul><h2 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h2><ul><li><p>在OpenGL中，GPU有2种渲染模式</p><ul><li>On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作</li><li>Off-Screen Rendering：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作</li></ul></li><li><p>离屏渲染消耗性能的原因</p><ul><li>需要创建新的缓冲区</li><li>离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen)切换到离屏（Off-Screen)，等到离屏渲染结束后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕</li></ul></li><li><p>哪些操作会触发离屏渲染？</p><ul><li>光栅化，layer.shouldRasterize = YES</li><li>遮罩，layer.mask</li><li>圆角，同时设置layer.maskToBounds = YES、layer.cornerRadius 大于0（考虑通过CoreGraphics绘制裁剪圆角，这个网上例子有很多我就不多说了，大家随便搜一搜都可以搜到，或者叫美工直接提供圆角图片）</li><li>阴影， layer.shadowXXX (但是如果设置了layer.shadowPath就不会产生离屏渲染了，不设置默认是环绕layer添加的)</li></ul></li></ul><p>喜欢的朋友可以扫描关注我的公众号(多谢支持）</p><p><a href="https://img.rruu.net/image/5e57d1ec32781" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://img.rruu.net/image/5e57d1ec32781" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      * 尽量减少视图数量和层次
   
   
 * 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示
   
   
 * 减少透明的视图（alpha&lt;1)，不透明的就设置opaque为YES
   
   
 * GPU能处理的最大纹理尺寸是4096*4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸
   
   
 * 尽量避免出现离屏渲染
   
   

离屏渲染
 * 在OpenGL中，GPU有2种渲染模式
   
    * On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作
    * O
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://lizhaobomb.github.io/tags/iOS/"/>
    
      <category term="性能优化" scheme="https://lizhaobomb.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS性能优化03-卡顿优化01-CPU</title>
    <link href="https://lizhaobomb.github.io/2020/02/28/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603-%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%9601-CPU/"/>
    <id>https://lizhaobomb.github.io/2020/02/28/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603-%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%9601-CPU/</id>
    <published>2020-02-27T16:20:47.000Z</published>
    <updated>2020-02-29T15:28:29.318Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>尽量使用轻量级的对象，比如用不到事件处理的地方，可以考虑使用CALayer取代UIView</p></li><li><p>不要频繁的调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改</p></li><li><p>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</p></li><li><p>Autolayout会比直接设置frame消耗更多的CPU资源</p></li><li><p>图片的size,最好刚好跟UIImageView的size保持一致</p></li><li><p>控制一下线程的最大并发数量</p></li><li><p>尽量把耗时的操作放到子线程里(比如<code>文本处理</code>和<code>图片处理</code>)</p><ul><li><p>文本处理 (尺寸计算、绘制）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 文字计算</span><br><span class="line">   [@&quot;text&quot; boundingRectWithSize:CGSizeMake(100, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:nil context:nil];</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 文字绘制</span><br><span class="line"> [@&quot;text&quot; drawWithRect:CGRectMake(0, 0, 100, 100) options:NSStringDrawingUsesLineFragmentOrigin attributes:nil context:nil];</span><br></pre></td></tr></table></figure></div></li></ul></li></ul><pre><code>- 图片处理（解码、绘制）我们一般都会用```imageView.image = [UIImage imageNamed:@&quot;***&quot;];```这种方式来获取图片，但这种方式是系统负责解码，而系统解码默认又是在主线程所以如果你的图片数据很大的时候就可能阻塞主线程从而造成卡顿，所以我们一般都是提前解码并且在子线程里进行，这样主线程就少了解码的操作到时候直接把解码的图片数据拿来用就好了，其实我们现在用的一些第三方图片处理库都有异步解码的功能了，我们来看一个例子（也是从三方库里拷贝过来的）代码有点多，其实核心步骤就是： 1.获取到图片的CGImage2.解码（解码的步骤就是）- 2.1 创建位图上下文- 2.2 把cgImage draw到上下文里，这样就完成了解码操作3.从上下文里获取刚解码过的图片4.最好再把解码过的图片包装成UIImage5.回到主线程的时候我们直接用解码过的图片就OK了（这样解码的操作都是在子线程里做的并不会阻塞主线程）</code></pre><p>下面我们来看看具体的代码实现    </p><pre><code>- (void)image{    UIImageView *imageView = [[UIImageView alloc] init];    imageView.frame = CGRectMake(100, 100, 100, 56);    [self.view addSubview:imageView];    self.imageView = imageView;    dispatch_async(dispatch_get_global_queue(0, 0), ^{        // 获取CGImage        CGImageRef cgImage = [UIImage imageNamed:@&quot;***&quot;].CGImage;        // alphaInfo        CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgImage) &amp; kCGBitmapAlphaInfoMask;        BOOL hasAlpha = NO;        if (alphaInfo == kCGImageAlphaPremultipliedLast ||            alphaInfo == kCGImageAlphaPremultipliedFirst ||            alphaInfo == kCGImageAlphaLast ||            alphaInfo == kCGImageAlphaFirst) {            hasAlpha = YES;        }        // bitmapInfo        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;        // size        size_t width = CGImageGetWidth(cgImage);        size_t height = CGImageGetHeight(cgImage);        // context        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo);        // draw        CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgImage);        // get CGImage        cgImage = CGBitmapContextCreateImage(context);        // into UIImage        UIImage *newImage = [UIImage imageWithCGImage:cgImage];        // release        CGContextRelease(context);        CGImageRelease(cgImage);        // back to the main thread        dispatch_async(dispatch_get_main_queue(), ^{            self.imageView.image = newImage;        });    });}</code></pre><p>喜欢的朋友可以扫描关注我的公众号(多谢支持）</p><p><a href="https://img.rruu.net/image/5e57d1ec32781" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://img.rruu.net/image/5e57d1ec32781" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      * 尽量使用轻量级的对象，比如用不到事件处理的地方，可以考虑使用CALayer取代UIView
   
   
 * 不要频繁的调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改
   
   
 * 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性
   
   
 * Autolayout会比直接设置frame消耗更多的CPU资源
   
   
 * 图片的size,最好刚好跟UIImageView的size保持一致
   
   
 * 控制一下线程的最大并发数量
   
   
 * 尽量把耗时的操作放到子线程
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://lizhaobomb.github.io/tags/iOS/"/>
    
      <category term="性能优化" scheme="https://lizhaobomb.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS性能优化02-产生卡顿的原因</title>
    <link href="https://lizhaobomb.github.io/2020/02/27/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602-%E5%8D%A1%E9%A1%BF%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>https://lizhaobomb.github.io/2020/02/27/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602-%E5%8D%A1%E9%A1%BF%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0/</id>
    <published>2020-02-27T13:20:47.000Z</published>
    <updated>2020-02-28T16:55:06.768Z</updated>
    
    <content type="html"><![CDATA[<ul><li>卡顿产生的主要原因CPU和GPU所花费的时间太长从而造成俗称的丢帧（掉帧）</li></ul><p>我们以下图为例，红色代表CPU，绿色代表GPU</p><p><a href="https://img.rruu.net/image/5e57d298d000f" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://img.rruu.net/image/5e57d298d000f" class="lazyload"></a></p><ol><li><p>首先把CPU把计算好的数据交给GPU去渲染，紧接着来一个VSync（垂直同步信号）就会把刚CPU计算好并且GPU渲染好的数据展示到屏幕上完成这一帧的显示，注意一旦发生一个VSync就会把GPU渲染到帧缓存里的数据显示到屏幕上，并且开始下一帧的操作，</p></li><li><p>我们第二帧的操作GPU花费的时间比较短还留出一段空闲时间等VSync的到来然后显示到屏幕上，但也有一种情况就是：</p></li><li><p>我们第三帧的操作，CPU计算完数据交给GPU去渲染，然而由于这次的数据比较多当VSync到来时，发现GPU还没有渲染完，上面我们也说了VSync一旦到来就会把GPU渲染到帧缓存里的数据显示到屏幕上，但是GPU并没有渲染完，所以只能显示上一帧的数据，也就意味着当前这帧数据丢失了，俗称丢帧或掉帧，而当前帧只能等下次VSync到来时再显示，因此就会造成卡顿（本来要显示当前帧结果只能显示前一帧）</p></li></ol><h1 id="卡顿解决的主要思路："><a href="#卡顿解决的主要思路：" class="headerlink" title="卡顿解决的主要思路："></a>卡顿解决的主要思路：</h1><ul><li>尽可能减少CPU、GPU资源消耗</li><li>一般我们要保证每秒60帧这样看起来就不会有什么问题了，那按照60FPS的刷帧率，每个16ms就会有一次VSync信号（为什么是16ms？因为1s=1000ms，1000ms/60~16ms）也就是说我们16ms内完成CPU和GPU操作就不会有什么卡顿问题了</li></ul><p>喜欢的朋友可以扫描关注我的公众号(多谢支持）</p><p><a href="https://img.rruu.net/image/5e57d1ec32781" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://img.rruu.net/image/5e57d1ec32781" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      * 卡顿产生的主要原因CPU和GPU所花费的时间太长从而造成俗称的丢帧（掉帧）

我们以下图为例，红色代表CPU，绿色代表GPU



 1. 首先把CPU把计算好的数据交给GPU去渲染，紧接着来一个VSync（垂直同步信号）就会把刚CPU计算好并且GPU渲染好的数据展示到屏幕上完成这一帧的显示，注意一旦发生一个VSync就会把GPU渲染到帧缓存里的数据显示到屏幕上，并且开始下一帧的操作，
    
    
 2. 我们第二帧的操作GPU花费的时间比较短还留出一段空闲时间等VSync的到来然后显示到屏幕上，但也有一种情况就是：
    
    
 3. 我们第三帧的操作，CPU计算完数据交
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://lizhaobomb.github.io/tags/iOS/"/>
    
      <category term="性能优化" scheme="https://lizhaobomb.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS性能优化01-CPU和GPU</title>
    <link href="https://lizhaobomb.github.io/2020/02/26/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601-CPU%E5%92%8CGPU/"/>
    <id>https://lizhaobomb.github.io/2020/02/26/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601-CPU%E5%92%8CGPU/</id>
    <published>2020-02-26T13:20:47.000Z</published>
    <updated>2020-02-29T15:28:15.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在屏幕成像的过程中-CPU和GPU起着至关重要的作用"><a href="#在屏幕成像的过程中-CPU和GPU起着至关重要的作用" class="headerlink" title="在屏幕成像的过程中,CPU和GPU起着至关重要的作用"></a>在屏幕成像的过程中,CPU和GPU起着至关重要的作用</h2><ul><li><p>CPU(Centeral Processing Unit，中央处理器)<br>对象的创建和销毁，对象属性的调整，布局计算，文本的计算和排版，图片的格式转换和解码、图像的绘制（Core Graphics）</p></li><li><p>GPU（Graphics Processing Unit，图形处理器）<br>纹理的渲染</p></li><li><p>CPU 和 GPU 工作原理</p><p>  CPU –计算–&gt;GPU–渲染–&gt;帧缓存–读取–&gt;视频控制器–显示–&gt;屏幕</p></li></ul><ul><li>iOS中是双缓存机制，有前帧缓存，后帧缓存</li></ul><h1 id="屏幕成像原理"><a href="#屏幕成像原理" class="headerlink" title="屏幕成像原理"></a>屏幕成像原理</h1><p>垂直同步信号（VSync）水平同步信号（HSync）</p><p>屏幕要显示一帧画面之前首先会发送一个VSync，紧接着就是一行一行的HSync，当<br>发送最后一行HSync的时候，就会接着发送下一个VSync，这样周而复始就是我们看到的屏幕画面了</p><p>VSync</p><p>|—————-&gt;  HSync</p><p>|—————-&gt;</p><p>|—————-&gt;</p><p>|—————-&gt;</p>]]></content>
    
    <summary type="html">
    
      在屏幕成像的过程中,CPU和GPU起着至关重要的作用
 * CPU(Centeral Processing Unit，中央处理器)
   对象的创建和销毁，对象属性的调整，布局计算，文本的计算和排版，图片的格式转换和解码、图像的绘制（Core Graphics）
   
   
 * GPU（Graphics Processing Unit，图形处理器）
   纹理的渲染
   
   
 * CPU 和 GPU 工作原理
   
    CPU –计算–&gt;GPU–渲染–&gt;帧缓存–读取–&gt;视频控制器–显示–&gt;屏幕
   
   

 * iOS中是双缓存机制，有前帧缓存，后帧缓存

屏幕成像原
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://lizhaobomb.github.io/tags/iOS/"/>
    
      <category term="性能优化" scheme="https://lizhaobomb.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>宏和const的区别</title>
    <link href="https://lizhaobomb.github.io/2016/11/02/%E5%AE%8F%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://lizhaobomb.github.io/2016/11/02/%E5%AE%8F%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2016-11-02T13:20:47.000Z</published>
    <updated>2020-02-27T15:21:55.213Z</updated>
    
    <content type="html"><![CDATA[<p>1、编译的时刻不一样<br>2、</p><p>const的简单实用</p><p>const作用：1.修饰右边基本变量或者指针变量 int a int *p<br>          2.被const修饰变量只读</p><p>int * const p;     //p只读，*p可以改    </p><p>int const * p;    //*p只读， p可以改</p><p>const int *p;     // *p只读，p变量</p><p>const int *const p;     //都是只读</p><p>int const *const p;    //都是只读</p>]]></content>
    
    <summary type="html">
    
      1、编译的时刻不一样
2、

const的简单实用

const作用：1.修饰右边基本变量或者指针变量 int a int *p
2.被const修饰变量只读

int * const p; //p只读，*p可以改 

int const * p; //*p只读， p可以改

const int *p; // *p只读，p变量

const int *const p; //都是只读

int const *const p; //都是只读
    
    </summary>
    
    
    
      <category term="宏" scheme="https://lizhaobomb.github.io/tags/%E5%AE%8F/"/>
    
      <category term="const" scheme="https://lizhaobomb.github.io/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://lizhaobomb.github.io/2016/10/08/hello-world/"/>
    <id>https://lizhaobomb.github.io/2016/10/08/hello-world/</id>
    <published>2016-10-08T14:35:23.000Z</published>
    <updated>2016-10-08T14:35:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.

Quick Start
Create a new post
1


$ hexo new &quot;My New Post&quot;


More info: Writing

Run server
1


$ hexo s
    
    </summary>
    
    
    
  </entry>
  
</feed>
