<!DOCTYPE html><html><head><meta charset="UTF-8"><title>iOS性能优化02-产生卡顿的原因</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/./css/style.css"><link rel="stylesheet" href="/./css/atom-one-dark.css"></head><body><header class="al_header al_pos_fixed"><div class="al_header_container dis_flex_jcenter"><div class="al_header_container_left"><div class="al_header_site_title"><a href="/">Hexo</a></div></div><div class="dis_flex_jcenter"><div class="al_header_setting"><svg class="al_header_icon"><use xmlns="http://www.w3.org/2000/svg" xlink:href="/assets/svg_icons.svg#svg-menu"></use></svg></div></div></div></header><div class="al_sidebar"><div class="al_sidebar_overlay al_full_cover"></div><div class="al_pos_fixed al_sidebar_cnt"><div class="dis_flex_acenter al_sidebar_header"><h3>Hexo</h3><div class="al_sidebar_close al_header_setting"><svg class="al_header_icon"><use xmlns="http://www.w3.org/2000/svg" xlink:href="/assets/svg_icons.svg#svg-close"></use></svg></div></div><div class="al_sidebar_author_cnt"><div class="al_sidebar_author_info"><h4>John Doe</h4><img class="al_sidebar_avatar" src="https://cdn.iguan7u.cn/image/avatar.jpg"><p></p></div></div></div></div><div class="al_page_background dis_flex_center al_full_cover"></div><div class="al_page_container"><div class="al_pos_ab al_fake_background"></div><div class="al_main_container al_main_page_container"><article class="al_article"><header><h1 class="al_page_title">iOS性能优化02-产生卡顿的原因</h1><div class="al_page_info dis_flex"><div class="al_page_content_info">Feb 27, 2020 9:20</div><div class="al_page_content_info">469 words</div><div class="al_page_content_info">1 minutes read</div><span class="tags"></span></div></header><div class="al_page_content_outline"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#卡顿解决的主要思路："><span class="toc-text">卡顿解决的主要思路：</span></a></li></ol></div><section id="post-body"><ul>
<li>卡顿产生的主要原因CPU和GPU所花费的时间太长从而造成俗称的丢帧（掉帧）</li>
</ul>
<p>我们以下图为例，红色代表CPU，绿色代表GPU</p>
<p><img src="https://img.rruu.net/image/5e57d298d000f" alt=""></p>
<ol>
<li><p>首先把CPU把计算好的数据交给GPU去渲染，紧接着来一个VSync（垂直同步信号）就会把刚CPU计算好并且GPU渲染好的数据展示到屏幕上完成这一帧的显示，注意一旦发生一个VSync就会把GPU渲染到帧缓存里的数据显示到屏幕上，并且开始下一帧的操作，</p>
</li>
<li><p>我们第二帧的操作GPU花费的时间比较短还留出一段空闲时间等VSync的到来然后显示到屏幕上，但也有一种情况就是：</p>
</li>
<li><p>我们第三帧的操作，CPU计算完数据交给GPU去渲染，然而由于这次的数据比较多当VSync到来时，发现GPU还没有渲染完，上面我们也说了VSync一旦到来就会把GPU渲染到帧缓存里的数据显示到屏幕上，但是GPU并没有渲染完，所以只能显示上一帧的数据，也就意味着当前这帧数据丢失了，俗称丢帧或掉帧，而当前帧只能等下次VSync到来时再显示，因此就会造成卡顿（本来要显示当前帧结果只能显示前一帧）</p>
</li>
</ol>
<h1 id="卡顿解决的主要思路："><a href="#卡顿解决的主要思路：" class="headerlink" title="卡顿解决的主要思路："></a>卡顿解决的主要思路：</h1><ul>
<li>尽可能减少CPU、GPU资源消耗</li>
<li>一般我们要保证每秒60帧这样看起来就不会有什么问题了，那按照60FPS的刷帧率，每个16ms就会有一次VSync信号（为什么是16ms？因为1s=1000ms，1000ms/60~16ms）也就是说我们16ms内完成CPU和GPU操作就不会有什么卡顿问题了</li>
</ul>
<p>喜欢的朋友可以扫描关注我的公众号(多谢支持）</p>
<p><img src="https://img.rruu.net/image/5e57d1ec32781" alt=""></p>
</section></article><nav class="dis_flex post-nav"><span class="prev"><a href="/2020/02/29/iOS性能优化03-卡顿优化01-CPU/"><span class="arrow">←</span>Newer Posts</a></span><span class="next"><a href="/2020/02/27/iOS性能优化01-CPU和GPU/">Older Posts<span class="arrow">→</span></a></span></nav></div></div><script type="text/javascript" src="/javascripts/highlight.pack.js"></script><script>document.querySelectorAll('figure.highlight').forEach(function(b){hljs.highlightBlock(b);});</script><div class="al_index_footer dis_flex dis_flex_center"><div class="al_index_footer_item al_index_footer_title">John Doe</div><div class="al_index_footer_item al_index_footer_extra">Create By <a href="https://github.com/iGuan7u/Acetolog">AcetoLog </a>· Power By <a href="https://hexo.io/">Hexo</a></div><div class="al_index_footer_item al_index_footer_extra_right">All Right Reserved</div></div><script type="text/javascript" async="async" src="/javascripts/acelog.js"></script></body></html>